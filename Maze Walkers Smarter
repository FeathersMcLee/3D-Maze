import bpy
import bmesh
import random
from mathutils import Vector, Matrix

# -----------------------
# Parameters
cell_size = 1.0         # thickness of each square pipe
padding = 0.0           # margin inside bounding box
seed = 42               # random seed
num_walkers = 30        # how many spaghetti strands
turn_chance = 0.3       # chance to turn even if forward is open
# -----------------------

random.seed(seed)

# --- Setup / bounding box ---
obj = bpy.context.active_object
if obj is None or obj.type != 'MESH':
    raise RuntimeError("Select a mesh object (the bounding volume) before running.")

bbox_size = Vector(obj.dimensions)
if min(bbox_size) <= 0:
    raise RuntimeError("Bounding object has invalid dimensions.")

nx = int((bbox_size.x - 2*padding) // cell_size)
ny = int((bbox_size.y - 2*padding) // cell_size)
nz = int((bbox_size.z - 2*padding) // cell_size)

if nx < 3 or ny < 3 or nz < 3:
    raise RuntimeError("Bounding object too small for given cell_size/padding.")

world_center = obj.matrix_world @ Vector((0.0, 0.0, 0.0))
grid_total = Vector((nx * cell_size, ny * cell_size, nz * cell_size))
origin = world_center - (grid_total / 2.0)

# --- Walker logic ---
dirs = [(1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)]
occupied = set()
cells = []

def in_bounds(x, y, z):
    return 0 <= x < nx and 0 <= y < ny and 0 <= z < nz

def free_neighbors(x, y, z):
    """Return all available directions from this cell."""
    valid = []
    for dx, dy, dz in dirs:
        nx2, ny2, nz2 = x + dx, y + dy, z + dz
        if in_bounds(nx2, ny2, nz2) and (nx2, ny2, nz2) not in occupied:
            valid.append((dx, dy, dz))
    return valid

for w in range(num_walkers):
    x = random.randrange(nx)
    y = random.randrange(ny)
    z = random.randrange(nz)
    direction = random.choice(dirs)
    dead = False

    while not dead:
        # mark current cell
        if (x, y, z) not in occupied:
            occupied.add((x, y, z))
            cells.append((x, y, z))

        # find possible moves
        options = free_neighbors(x, y, z)
        if not options:
            dead = True
            break

        # decide whether to turn preemptively
        forward = (x + direction[0], y + direction[1], z + direction[2])
        forward_free = in_bounds(*forward) and forward not in occupied

        if not forward_free or random.random() < turn_chance:
            # turn, but never reverse direction
            choices = [d for d in options if d != (-direction[0], -direction[1], -direction[2])]
            if choices:
                direction = random.choice(choices)
            else:
                dead = True
                break

        # move forward
        x += direction[0]
        y += direction[1]
        z += direction[2]

# --- Geometry creation ---
bm = bmesh.new()

def cell_center(i, j, k):
    return origin + Vector(((i + 0.5) * cell_size,
                            (j + 0.5) * cell_size,
                            (k + 0.5) * cell_size))

for (i, j, k) in cells:
    M = Matrix.Translation(cell_center(i, j, k))
    bmesh.ops.create_cube(bm, size=cell_size, matrix=M)

bmesh.ops.remove_doubles(bm, verts=bm.verts, dist=1e-6)

mesh_data = bpy.data.meshes.new("SmartWalkerSpaghettiMesh")
bm.to_mesh(mesh_data)
bm.free()

walker_obj = bpy.data.objects.new("SmartWalkerSpaghetti", mesh_data)
bpy.context.collection.objects.link(walker_obj)
walker_obj.select_set(True)
bpy.context.view_layer.objects.active = walker_obj
mesh_data.update()

print(f"Generated SmartWalkerSpaghetti: {len(cells)} cubes, {num_walkers} walkers, cell={cell_size}")
