import bpy
import bmesh
import random
from mathutils import Vector, Matrix

# -----------------------
# User parameters
cell_size = 1.0        # thickness of each square pipe (units)
padding = 0.0          # margin inside bounding box
seed = 42              # random seed (change for variation)
num_walkers = 1       # number of independent spaghetti strands
steps_per_walker = 200 # how long each strand can grow
turn_chance = 0.3      # chance to turn 90° at each step
# -----------------------

random.seed(seed)

# --- Setup / bounding box ---
obj = bpy.context.active_object
if obj is None or obj.type != 'MESH':
    raise RuntimeError("Select a mesh object (the bounding volume) before running.")

bbox_size = Vector(obj.dimensions)
if min(bbox_size) <= 0:
    raise RuntimeError("Bounding object has invalid dimensions.")

nx = int((bbox_size.x - 2*padding) // cell_size)
ny = int((bbox_size.y - 2*padding) // cell_size)
nz = int((bbox_size.z - 2*padding) // cell_size)

if nx < 3 or ny < 3 or nz < 3:
    raise RuntimeError("Bounding object is too small for given cell_size/padding.")

world_center = obj.matrix_world @ Vector((0.0, 0.0, 0.0))
grid_total = Vector((nx * cell_size, ny * cell_size, nz * cell_size))
origin = world_center - (grid_total / 2.0)

# --- Walker maze generation ---
occupied = set()
dirs = [(1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)]
cells = []  # store visited cells

for w in range(num_walkers):
    x = random.randrange(nx)
    y = random.randrange(ny)
    z = random.randrange(nz)
    direction = random.choice(dirs)

    for _ in range(steps_per_walker):
        # Mark current cell if not yet used
        if (x,y,z) not in occupied:
            occupied.add((x,y,z))
            cells.append((x,y,z))

        # Randomly decide to turn 90°
        if random.random() < turn_chance:
            # pick new direction perpendicular to current one
            candidates = [d for d in dirs if d != (-direction[0], -direction[1], -direction[2])]
            direction = random.choice(candidates)

        # Step forward
        nx2, ny2, nz2 = x + direction[0], y + direction[1], z + direction[2]
        # Stop if outside bounds or would collide with existing cell (to avoid touching)
        if not (0 <= nx2 < nx and 0 <= ny2 < ny and 0 <= nz2 < nz):
            break
        if (nx2, ny2, nz2) in occupied:
            break
        x, y, z = nx2, ny2, nz2

# --- Geometry creation ---
bm = bmesh.new()

def cell_center(i, j, k):
    return origin + Vector(((i + 0.5) * cell_size,
                            (j + 0.5) * cell_size,
                            (k + 0.5) * cell_size))

for (i, j, k) in cells:
    M = Matrix.Translation(cell_center(i,j,k))
    bmesh.ops.create_cube(bm, size=cell_size, matrix=M)

bmesh.ops.remove_doubles(bm, verts=bm.verts, dist=1e-6)

mesh_data = bpy.data.meshes.new("WalkerSpaghettiMesh")
bm.to_mesh(mesh_data)
bm.free()

walker_obj = bpy.data.objects.new("WalkerSpaghetti", mesh_data)
bpy.context.collection.objects.link(walker_obj)
walker_obj.select_set(True)
bpy.context.view_layer.objects.active = walker_obj

mesh_data.update()
print(f"Generated WalkerSpaghetti: {len(cells)} cubes, {num_walkers} walkers, cell={cell_size}")
